// Malware.cpp : définit le point d'entrée pour l'application console.
//

#include "stdafx.h"
#include<stdio.h>
#include<string.h>
#include <Windows.h>
#include <winternl.h>
#include <iostream>
#include <stdlib.h>

/*--------------------------------------------------------------------------------------*/
//Octets de départ de la fonction strcmp pour la remplacer plus tard (A VERIFIER JE SUIS PAS SUR DE MOI ALED)
char start_strcmp[] = {'\x8b', '\x54', '\x24', '\x04', '\x8b', '\x4c', '\x24', '\x08', '\xf7', '\xc2', '\x03', '\x00'};

//Octets de départ de scanf (A VERIFIER JE SUIS PAS SUR DE MOI ALED v2)
char start_scanf[] = {'\x8b', '\xff', '\x55', '\x8b', '\xec', '\x8d', '\x45', '\x0c', '\x50', '\x6a', '\x00', '\xff'};
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Bonne clef
//Jsp si on la garde ici ?
char key[] = "12345678";
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Mauvaises clefs, sert de leurre => A chiffrer btw
char *clef1 = "12345678910";
char *clef2 = "123456789";
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Fonction(s) de bait
//Faire une fausse fonction de verification avec strcmp
//Faire la modif de l'assembleur pour sauter les instruction si possible :>
__declspec(noinline) int verif(char *clef){
	int res = 0;
	//On fait un check avec strcmp, puis on modifie le resultat. Voir le git
	return res;
}
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Fonction de chiffrement, à compléter
__declspec(noinline) char* encode(char* input){
	printf("(Je chiffre l'entree la...)\n");
	return input;
}
/*--------------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------------*/
// Programme principale
int main(int argc, char* argv[])
{
/*-----------------------*/
	//Verification des argument
	if(argc!=2){
		fprintf(stderr, "Il faut un unique argument.\nUsage: prog.exe <clef_secrete>\n");
		Sleep(3000);//A remplacer par un truc marrant hihi
		return 1;
	}
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
	//Programme principale. A modifier si besoin
	/*Eventuellement faire un: 
	if (CheckDebugger){
		fausse boucle principale => Avec une autre fonction de chiffrement, des leurres etc...
	} else {
		boucle principale
	}
	*/

	char* input = argv[1];
	int success = 0;
	size_t len = strlen(input);
	int validInput = 1;
		
/*--------------------------------------------------------------------------------------*/
	//Vérification de la validité de l'input
	for (size_t i = 0; i < len; i++) {
		if (!isxdigit(input[i])) { // Vérifier si le caractère est un chiffre hexadécimal
			validInput = 0;
			break;
		}
	}
/*--------------------------------------------------------------------------------------*/
	//Vérification de la clef
	if(validInput && len <=32){
		//Remplacer strcmp par un appel caché
		if (strcmp(encode(input), key) == 0){
			success = 1;
			printf("\nBravo, vous avez trouve !");
			Sleep(5000);
		} else {
			printf("%s\n", input);
		}
	} else {
		//On peut tout casser OUAIS !!
		printf("Entree invalide.\n\n");
	}
	while(1);
/*--------------------------------------------------------------------------------------*/
	return 0;
}

