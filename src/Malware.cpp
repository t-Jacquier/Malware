// Malware.cpp: définit le point d'entrée pour l'application console.
//

#include "stdafx.h"
#include<stdio.h>
#include<string.h>
#include <Windows.h>
#include <winternl.h>
#include <iostream>
#include <stdlib.h>
#include <stdint.h>


/*--------------------------------------------------------------------------------------*/
//Octets de départ de la fonction strcmp pour la remplacer plus tard
char start_strcmp[] = {'\x8b', '\x54', '\x24', '\x04', '\x8b', '\x4c', '\x24', '\x08', '\xf7', '\xc2', '\x03', '\x00'};
typedef int (*type_strcmp)(const char* f, const char* s);

//Octets de départ de scanf
char start_scanf[] = {'\x8b', '\xff', '\x55', '\x8b', '\xec', '\x8d', '\x45', '\x0c', '\x50', '\x6a', '\x00', '\xff'};

char start_printf[] ={'\x6a', '\x0c', '\x68', '\x60', '\x57', '\xb0', '\x78', '\xe8', '\xc0', '\xb5', '\xfa', '\xff'};
typedef int (*type_printf) (const char *, ...);
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Bonne clef
//Jsp si on la garde ici ?
char key[] = "6353182734632795781";
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Mauvaises clefs, sert de leurre => A chiffrer btw
char *K9jL3p = "3242760882647266555";
char *RqV7yB5 = "14636027152201056717";
char *U3kN4f = "6592631096633847903";
char *rD4lS9E= "12929994912295162778";
char *wKuXvJi = "4902274480959911086";
char *FhTmWnY = "15183140866687063214";
char *aG6jL0p = "4196321903662675195";
char *bUgQkZ1 = "17991039734974910389";
char *D1oG9h = "8006894215236070159";
char *C7wP8a = "4196321903662675195";
char *fM3xN1t = "773248505448545303";
char *H8oIzC2 = "773248505448545303";
char *P8sQ2aF= "16133048432034582751";
char *hL6mZ9R = "7582080364016931644";
char *tN3pD7x = "7582080364016931644";
char *oI2rM9l = "12455576196109436096";
char *Y4bW5cK = "17915509194030949278";
char *A5uH3yG = "6884772172714027130";
char *vB9wR1h = "10542651408111992557";
char *eC4iS0j = "7881746386079524";
char *JqV1gE6 = "6803080911664372943";

char *clef67 = "67";
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Fonction(s) de bait
//Faire une fausse fonction de verification avec strcmp
//Faire la modif de l'assembleur pour sauter les instruction si possible :>
__declspec(noinline) int verif(char *clef){
	int res = 0;
	//On fait un check avec strcmp, puis on modifie le resultat en assembleur
	if(strcmp(clef, clef67)){
		res = 1;
	}
	//Modification de res en assembleur
	// Voir comment ca rends dans le debuggueur ?
	__asm{
		mov eax, res
		xor eax, eax
		mov res, eax
	}
	return res;
}
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//convertir en str (nom a changer)
char* subsitution(uint64_t num) {
    char* str = (char*)malloc(21 * sizeof(char)); 
 

    int i = 0;
    do {
        str[i++] = num % 10 + '0';
        num /= 10;
    } while (num != 0);

    str[i] = '\0';

    int j = 0;
    i--;
    while (j < i) {
        char temp = str[j];
        str[j] = str[i];
        str[i] = temp;
        j++;
        i--;
    }
	
    return str;
}

/*--------------------------------------------------------------------------------------*/
//fonction fake d'encode (a changer le nom)
char* customEncrypt_fake2(char* s, size_t len) {
    uint64_t h = 145;

    for (size_t i = 0; i < len; ++i) {
        h = ((h << 3) + h) ^ s[i];
        h += h << 12;
    }

    h ^= h >> 8;
    h += h << 3;
    h ^= h >> 10;
    h += h << 7;

	char* c = subsitution(h);
	
	return c;
}

/*--------------------------------------------------------------------------------------*/

//Fonction de chiffrement
__declspec(noinline) char* encode(char* input, size_t len){
	uint64_t h = 145;
	
    for (size_t i = 0; i < len; ++i) {
        h = ((h << 5) + h) ^ input[i];
        h += h << 13;
    }

    h ^= h >> 7;
    h += h << 3;
    h ^= h >> 17;
    h += h << 7;

	char* c = subsitution(h);
	
	return c;
}
/*--------------------------------------------------------------------------------------*/
//fonction fake d'encode (a changer le nom)
char* customEncrypt_fake(char* s, size_t len) {
    uint64_t h = 145;

    for (size_t i = 0; i < len; ++i) {
        h = ((h << 3) + h) ^ s[i];
        h += h << 12;
    }

    h ^= h >> 7;
    h += h << 3;
    h ^= h >> 17;
    h += h << 7;

	char* c = subsitution(h);
	
	return c;
}

/*--------------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------------*/
// Programme principale
int main(int argc, char* argv[])
{

/*--------------------------------------------------------------------------------------*/
	//Nouveau type pour printf 
	/*char *p = (char *) scanf; => Marche po: Edit, je suis con j'utilise pas le bon debut
	type_printf mon_print;
	int found = 0;
	while(!found){
		if(memcmp(p, start_scanf, 12) == 0){found = 1; }
		else{ p--; }
	}
	mon_print = (type_printf) p;
	mon_print("HELLOW WORLD?"); */
	//==>> Faire pareil avec le strcmp et l'ajouter dans les trucs en bas
	//Remplacez les printf par les appels de ce truc la
/*--------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------*/
	//Verification des argument
	if(argc!=2){
		fprintf(stderr, "Il faut un unique argument.\nUsage: prog.exe <clef_secrete>\n");
		Sleep(3000);//A remplacer par un truc marrant hihi
		return 1;
	}
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
	//Programme principale. A modifier si besoin

/*--------------------------------------------------------------------------------------*/
	//On utilise les trois vérifications pour voir si il y a des debugguer
	//Premiere verif, en demandant a Windows
	int X = IsDebuggerPresent();

	//Deuxieme verif, en demandant encore a Windows.
	BOOL Y;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &Y );


	//Derni?re verif, sans demander a Windows. On stock le resultat dans Z.
	PEB *ppeb;
	__asm{
		mov ebx, 0x20
		mov ecx, 0x10
		mov edx, fs:[ebx+ecx]
		mov ppeb, edx

	}
	char *p = (char *) ppeb;
	int Z = (p[104] & 0x70);
/*--------------------------------------------------------------------------------------*/

	//Décalage de strcmp
	char* adr = (char*) strlen;
	while(memcmp(adr, start_strcmp, 12) != 0){
		adr--;
	}

	type_strcmp cmp = (type_strcmp) adr;

/*--------------------------------------------------------------------------------------*/
	//Variables utiles pour la suite...
	char* input = argv[1]; //L'argument d'entr?e
	int success = 0; //Bool de test pour la validit? de la chaine
	size_t len = strlen(input); //Taille de l'input
	int validInput = 1; //Bool de test valid input

	//Vérification de la validité de l'input
	for (size_t i = 0; i < len; i++) {
		if (!isxdigit(input[i])) { // V?rifier si le caractère est un chiffre hexad?cimal
			validInput = 0;
			break;
		}
	}
/*--------------------------------------------------------------------------------------*/
	//Verification de la validité de l'input
	if(validInput && len <=32){

		//On verifie si il y a un debug via les trois bool de tout a l'heure
		if(X || Y || Z){
			printf("Chef, y a un debug \n"); //A virer
			 char *test = encode(input, strlen(input)); // A virer
			 printf("test = %s\n", test); // A virer
			//(Leurre) V?rification de la clef 
			int bleg = verif(encode(input, strlen(input)));
			
			if(bleg){
				printf("\nBRavo, vous avez trouve !");
				while(1);
				return 0;
			} else {
				printf("%s\n", input);
			}

		//Pas de debug + entree correcte, on deroule le programme
		} else {
			printf("pas de debug chef \n"); //A virer
			//Remplacer strcmp par un appel caché
			//Verification de l'input par rapport a la clef
		
			if (cmp(encode(input, strlen(input)), key) == 0){
				success = 1;
				printf("\nBravo, vous avez trouve !");
				Sleep(5000);
			} else {
				//Mauvaise clef, on affiche la chaine elle meme
				printf("%s\n", input);
			}
		}
	
	//Input invalide
	} else {
		//On peut tout casser OUAIS !!
		printf("Entree invalide.\n\n");
	}
	while(1);
	return 0;
}

