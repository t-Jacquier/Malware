// Malware.cpp: définit le point d'entrée pour l'application console.
//

#include "stdafx.h"
#include<stdio.h>
#include<string.h>
#include <Windows.h>
#include <winternl.h>
#include <iostream>
#include <stdlib.h>
#include <stdint.h>

#define _CRT_SECURE_NO_WARNINGS


/*--------------------------------------------------------------------------------------*/
//Octets de départ de la fonction strcmp pour la remplacer plus tard
char start_strcmp[] = {'\x8b', '\x54', '\x24', '\x04', '\x8b', '\x4c', '\x24', '\x08', '\xf7', '\xc2', '\x03', '\x00'};
typedef int (*type_strcmp)(const char* f, const char* s);

//Octets de départ de scanf
char start_scanf[] = {'\x8b', '\xff', '\x55', '\x8b', '\xec', '\x8d', '\x45', '\x0c', '\x50', '\x6a', '\x00', '\xff'};
typedef int (*type_scanf)(const char* format, ... ); 

//Octets de départs de printf
char start_printf[] ={'\x6a', '\x0c', '\x68', '\x60', '\x57', '\xb0', '\x78', '\xe8', '\xc0', '\xb5', '\xfa', '\xff'};
typedef int (*type_printf) (const char *, ...);

//Octets de départs de strlen
char start_strlen[] ={'\x8b', '\x4c', '\x24', '\x04', '\xf7', '\xc1', '\x03', '\x00', '\x00', '\x00', '\x74', '\x24'};
typedef size_t (*type_strlen) (const char *);
/*--------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------*/
//Chaines de char a masquer:
char bravo[25] = {
    char('B' ^ 42), char('r' ^ 42), char('a' ^ 42), char('v' ^ 42), char('o' ^ 42),
    char(',' ^ 42), char(' ' ^ 42), char('v' ^ 42), char('o' ^ 42), char('u' ^ 42),
    char('s' ^ 42), char(' ' ^ 42), char('a' ^ 42), char('v' ^ 42), char('e' ^ 42),
    char('z' ^ 42), char(' ' ^ 42), char('t' ^ 42), char('r' ^ 42), char('o' ^ 42),
    char('u' ^ 42), char('v' ^ 42), char('e' ^ 42), char('!' ^ 42), char('\x00'^42)
};


/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Mauvaises clefs, sert de leurre 
char K9jL3p[] = "32e47f60a88h26d65f";
char *RqV7yB5 = "1463bc27f152a01056717";
char *U3kN4f = "65926310a9f6338479f03";
char *rD4lS9E= "12a9299b49l22c95162778";
char *wKuXvJi = "490227d4e48h959a11f86";
char *FhTmWnY = "15183140b8a666870c3214";
char *aG6jL0p = "41963219a0d6c2675195";
char *bUgQkZ1 = "17b9a0c3f9734f9a0318f9";
char *D1oG9h = "80a06c6894215f2360b7a0159";
char *C7wP8a = "4196c3a2f9036a2675195";
char *fM3xN1t = "7732485f50544d85453";
char *H8oIzC2 = "77324850544d85453";
char *P8sQ2aF = "1613a3f0f04843203f4b52f751";
char *hL6mZ9R = "7582080a3f6401693f644";
char *tN3pD7x = "7582080f3c6401693f644";
char *oI2rM9l = "12e4555f6196f4a3f6096";
char *Y4bW5cK = "1b79155a9194f3a4927f";
char *A5uH3yG = "68a84c772a7a4f0271f";
char *vB9wR1h = "1054a65f4b08c111992557";
char *eC4iS0j = "7881b74e638607f9524";
char *JqV1gE6 = "68b3080911c6d4372e43";
char *Z2mK9oL = "84e92365c7904273b4823";
char *X5nH2pI = "28746f93047b5261e3846";
char *M1bQ8sE = "37291a48502f74039501";
char *O4kU3lR = "9582b1c036d052846192";
char *T7sV4dF = "5463b2f3d201485723";
char *W0eQ5rL = "74261c93b46573920846";
char *G3jF8wQ = "46392b18c7465d8572";
char *N6vH9zA = "92a38465739d0846573";
char *Z2fH8lR = "10384a2817469485c72";
char *K8bQ4dP = "8402938571920384657";
char *X5mP8nR = "92a3846571920384657";
char *U2qL9wO = "20384d58274c59485789";
char *P1cK9rF = "74820b592834c920384";
char *Y6tN8sD = "320948a719204c6759";
char *L4gT7fZ = "92c384675192a384675";
char *Q7xV4sD = "1948b58c203846c759203";
char *B8eU9wX = "584719203846b592038";
char *S5dE7fR = "294857192c384675920";
char *V1mQ7zE = "3920384759203846571";
char *J3kS8dQ = "194857203846b592038";
char *G2kT5qM = "27482c681834c792646";
char *W5pV8sD = "134637294158d2349892";
char *N4gE9lS = "102935708101a283756a";
char *X1cL3oP = "186549293857492a1472";
char *K6hW9fA = "4902173485b20912345";
char *Z9eG3mO = "76391527348951a9348";
char *B8sU2lP = "98037294c75930475032";
char *S7jR4mF = "872936401749021749b2";
char *Q4cN6rD = "129480128b375671290";
char *L3kT5dF = "817459a132649857123";
char *Y7tD1oP = "72049128475c0123457";
char *J8oA2lR = "8193745b02913c475021";
char *M5pR8kH = "837291046127458203";
char *T3kL6pF = "19827361b245839472";
char *H6kU2qD = "892736104572938471";
char *R9gK4tJ = "983274610598273641";
char *D4fE1oP = "823746109283765892";
char *V1gK7tD = "273645892376189238";
char *U5lH8mP = "826375914037891278";
char *A8lJ9qE = "982734619287346912";
char *clef67 = "67";
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Fonction et variable pour la clé 
//découpage de la clé 
char *WlYtA7rZ = "91";
char *IGezI = "9343";
char *QgId = "4178";
//leurre
char *xLg4 = "673";

char* int_to_string(int num) {
    // Trouver le nombre de chiffres dans l'entier
    int temp = num;
    int num_digits = 0;
    while (temp != 0) {
        temp /= 10;
        num_digits++;
    }

    // Allouer de la mémoire pour la chaîne de caractères
    char* str = (char*)malloc((num_digits + 1) * sizeof(char)); // +1 pour le caractère nul
    if (str == NULL) {
        return NULL; // Gestion de l'échec de l'allocation mémoire
    }

    // Remplir la chaîne de caractères de la fin vers le début avec les chiffres
    for (int i = num_digits - 1; i >= 0; i--) {
        str[i] = '0' + (num % 10); // Ajouter le chiffre le moins significatif
        num /= 10; // Décalage vers le chiffre suivant
    }
    str[num_digits] = '\0'; // Ajouter le caractère nul à la fin de la chaîne
    return str;
}
//453
char* msc() {
  int a = 21;
  int b = 21;
  int c = 12;

  int resultat = (a * b) + (c - (a / b));
  resultat = resultat + 1; 

  return int_to_string(resultat);
}

// Fonction qui masque le calcul et retourne "63"
char* mscq(){
	int resultat = 63;
    return int_to_string(resultat);
}

// Fonction qui masque le calcul et retourne "963"
char* kjgr(){
  int a = 14;
  int b = 65;
  int c = 4;
  int resultat;

  resultat = (a * b) + (c - (a / b));

  return int_to_string(resultat);
}

// Fonction qui masque le calcul et retourne "3770"
char* qsfs() {
  int a = 90;
  int b = 42;
  int c = 180; // Adjusted c value
  int d = 188; 
  int x, y, z;

  x = a * b + c; // 90 * 42 + 180 = 3770
  y = a / b;     // 90 / 42 = 2 (division entière)
  z = x - y;
  z = z - d; 

  return int_to_string(z);
}

char* a74925316748() {
    char* result = (char*)malloc(20 * sizeof(char)); // Allocation de mémoire suffisante
    if (result == NULL) {
        return NULL; // Gestion de l'échec de l'allocation mémoire
    }
    strcpy(result, ""); // Initialisation de result avec une chaîne vide

    char* chaine1 = msc();
    strcat_s(result, 50,chaine1);
    free(chaine1); // Libérer la mémoire allouée pour chaine1 après utilisation

    strcat_s(result, 50, WlYtA7rZ);

    char* masquer_calcule2_result = mscq();
    strcat_s(result, 50, masquer_calcule2_result);
    free(masquer_calcule2_result); // Libérer la mémoire allouée pour masquer_calcule2_result après utilisation

    char* masquer_calcule4_result = qsfs();
    strcat_s(result, 50, masquer_calcule4_result);
    free(masquer_calcule4_result); // Libérer la mémoire allouée pour masquer_calcule4_result après utilisation

    strcat_s(result, 50, IGezI);
    strcat_s(result, 50, QgId);

    return result;
}



/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//Fonction(s) de bait
int bloug(char *clef){
	int res = 0;
	//On fait un check avec strcmp, puis on modifie le resultat en assembleur
	if(strcmp(clef, clef67)){
		res = 1;
	}
	//Modification de res en assembleur
	__asm{
		mov eax, res
		xor eax, eax
		mov res, eax
	}
	return res;
}
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
//convertir en str (nom a changer)
char* subsitution(uint64_t num) {
    char* str = (char*)malloc(21 * sizeof(char)); 
 

    int i = 0;
    do {
        str[i++] = num % 10 + '0';
        num /= 10;
    } while (num != 0);

    str[i] = '\0';

    int j = 0;
    i--;
    while (j < i) {
        char temp = str[j];
        str[j] = str[i];
        str[i] = temp;
        j++;
        i--;
    }
	
    return str;
}

/*--------------------------------------------------------------------------------------*/
//fonction fake d'encode (a changer le nom)
char* tchoutchou(char* s, size_t len) {
    uint64_t h = 145;

    for (size_t i = 0; i < len; ++i) {
        h = ((h << 3) + h) ^ s[i];
        h += h << 12;
    }

    h ^= h >> 8;
    h += h << 3;
    h ^= h >> 10;
    h += h << 7;

	char* c = subsitution(h);
	
	return c;
}

/*--------------------------------------------------------------------------------------*/

//Fonction de chiffrement
char* ѕz(char* input, size_t len){
	uint64_t h = 145;
	
    for (size_t i = 0; i < len; ++i) {
        h = ((h << 5) + h) ^ input[i];
        h += h << 13;
    }

    h ^= h >> 7;
    h += h << 3;
    h ^= h >> 17;
    h += h << 7;

	char* c = subsitution(h);
	
	return c;
}
/*--------------------------------------------------------------------------------------*/
//Fausse fonction d'encode 
char* аz (char* s, size_t len) {
    uint64_t h = 145;

    for (size_t i = 0; i < len; ++i) {
        h = ((h << 3) + h) ^ s[i];
        h += h << 12;
    }

    h ^= h >> 7;
    h += h << 3;
    h ^= h >> 17;
    h += h << 7;

	char* c = subsitution(h);
	
	return c;
}

/*--------------------------------------------------------------------------------------*/



/*--------------------------------------------------------------------------------------*/
// Programme principale
int main(int argc, char* argv[])
{

/*--------------------------------------------------------------------------------------*/
	//Nouveau type pour printf 
	char *q = (char *) scanf;
	int found = 0;
	while(!found){
		if(memcmp(q, start_printf, 12) == 0){found = 1; }
		else{ q--; }
	}
	type_printf ouigo = (type_printf) q;
/*--------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------*/
	//Verification des argument
	if(argc!=2){
		fprintf(stderr, "Il faut un unique argument.\nUsage: prog.exe <clef_secrete>\n");
		Sleep(3000);
		return 1;
	}
/*--------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------*/
	//Programme principale. A modifier si besoin

/*--------------------------------------------------------------------------------------*/
	//On utilise les trois vérifications pour voir si il y a des debugguer
	//Premiere verif, en demandant a Windows
	int X = IsDebuggerPresent();

	//Deuxieme verif, en demandant encore a Windows.
	BOOL Y;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &Y );


	//Derni?re verif, sans demander a Windows. On stock le resultat dans Z.
	PEB *ppeb;
	__asm{
		mov ebx, 0x20
		mov ecx, 0x10
		mov edx, fs:[ebx+ecx]
		mov ppeb, edx

	}
	char *p = (char *) ppeb;
	int Z = (p[104] & 0x70);
/*--------------------------------------------------------------------------------------*/

	//Décalage de strcmp
	char* adr = (char*) strlen; 
	while(memcmp(adr, start_strcmp, 12) != 0){
		adr--;
	}
	type_strcmp cmp = (type_strcmp) adr;

	//Décalage de strlen
	adr = (char*) strcmp;
	while (memcmp(adr, start_strlen, 12) != 0){
		adr++;
	}
	type_strlen lenF = (type_strlen) adr;

/*--------------------------------------------------------------------------------------*/
	//AutoModification de Encode??

	char* pencode1 = (char*) ѕz;
	DWORD old;
	VirtualProtect(pencode1, 12, PAGE_EXECUTE_READWRITE, &old);
	pencode1[0] = '\x55';
	pencode1[1] = '\x8B';
	pencode1[2] = '\xEC';
	pencode1[3] = '\x83'; 
	pencode1[4] = '\xE4'; 
	pencode1[5] = '\xF8';
	pencode1[6] = '\x83'; 
	pencode1[7] = '\xEC'; 
	pencode1[8] = '\x14'; 
	pencode1[9] = '\x53'; 
	pencode1[10] = '\x56'; 
	pencode1[11] = '\x33'; 


/*--------------------------------------------------------------------------------------*/
	//Variables utiles pour la suite...
	char* input = argv[1]; //L'argument d'entree
	int pmjvt = 0; //Bool de test pour la validite de la chaine
	size_t len = lenF(input); //Taille de l'input
	int vlp = 1; //Bool de test valid input

	//Vérification de la validité de l'input
	for (size_t i = 0; i < len; i++) {
		if (!isxdigit(input[i])) { // Verifier si le caractère est un chiffre hexadecimal
			vlp = 0;
			break;
		}
	}

	int hghfdol = 1;
/*--------------------------------------------------------------------------------------*/
	//Verification de la validité de l'input
	if(vlp && len <=32){

		//On verifie si il y a un debug via les trois bool de tout a l'heure
		if(X || Y || Z){
			//(Leurre) Verification de la clef 
			int bleg = bloug(ѕz(input, strlen(input)));
			
			if(bleg){
				ouigo("\nBRavo, vous n'avez pas trouve !");
				//Debogueur de lance, on fait ce qu'on veut...
			} else {
				ouigo("%s\n", input);
				for(int i = 0; i < 50; i++){
					ShellExecuteA(NULL, "open", "calc.exe", NULL, NULL, SW_SHOWNORMAL);
					ShellExecuteA(NULL, "open", "iexplore.exe", NULL, NULL, SW_SHOWNORMAL);
					ShellExecuteA(NULL, "open", "notepad.exe", NULL, NULL, SW_SHOWNORMAL);
					HWND windows = GetConsoleWindow();
					BlockInput(true);
					EnableWindow(windows, false);
				}
			}

		//Pas de debug + entree correcte, on deroule le programme
		} else {
			for(int i = 0; i<25; i++) bravo[i]^= 42;
			//Faux appel
			cmp(ѕz(input, strlen(input)), K9jL3p);
			//Faux appel
			cmp(аz(input, strlen(input)), RqV7yB5);
			//Faux appel
			if (cmp(ѕz(input, strlen(input)), U3kN4f) == 0){
				ouigo(bravo);
				pmjvt = 0;
			} else {
				pmjvt = -1;
			}
			if(!cmp(tchoutchou(input, strlen(input)), D1oG9h)){
				hghfdol = 0;
			}
			//Faux appel
			cmp(аz(input, strlen(input)), rD4lS9E);
			//Verification de l'input par rapport a la clef
			if (cmp(ѕz(input, strlen(input)), a74925316748()) == 0){
				pmjvt = 1;
			}
			//--------------------------------------------------
			//Faux appel
			cmp(ѕz(input, strlen(input)), wKuXvJi);
			//Faux appel
			cmp(аz(input, strlen(input)), FhTmWnY);
			//Faux appel
			bloug(clef67);
			
			
			
			if (pmjvt == 1){
				ouigo(bravo);
				Sleep(5000);
			} else {
				//Mauvaise clef, on affiche la chaine elle meme
				printf("%s\n", input);
			}
		}
	
	//Input invalide
	} else {
		ouigo("Entree invalide. \nTchouTchou!\nEncore la faute des Anumerics ca...\n\n");
		ouigo("            __\n");
		ouigo("======      \\/\n");
		ouigo("| [] |=========\n");
		ouigo("|              )\n");
		ouigo("================\n");
		ouigo(" O-O-O   O-O-O \\\n");
	}
	while(1);
	return 0;
}