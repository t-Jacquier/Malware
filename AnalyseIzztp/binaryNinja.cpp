// Fais une comparaison entre un arg1 et la chaine "bdea63d1cb70184f84d9d0585c8c7e96"
int32_t sub_401000(int32_t arg1)
{
    int32_t i = 0;
    int32_t var_24;
    __builtin_strncpy(&var_24, "bdea63d1cb70184f84d9d0585c8c7e96", 0x20);
    do
    {
        int32_t __saved_ebp;
        if (*((arg1 - &var_24) + ((&__saved_ebp + i) - 0x20)) != *((&__saved_ebp + i) - 0x20))
        {
            i = 0;
            return i;
        }
        i = (i + 1);
    } while (i < 0x20);
    i = 1;
    return i;
}

//Fonction principale
int32_t sub_401080(int32_t arg1, void* arg2)
{
    if (arg1 < 2) // Verifie le nombre d'argument
    {
        return 0;
    }


    printf(&data_4020f4, *(arg2 + 4)); 
    //data_4020f4 => Variable Globale.
    //arg2+4 => accède a la valeur pointée par arg2 (AKA: la chaine qu'on entre pour tester)


    void* fsbase;
    if (*(*(fsbase + 0x30) + 2) != 0)
    /*Cette condition vérifie la valeur d'un octet dans la mémoire accédée 
    par une manipulation d'adresse via fsbase. 
    Si cette valeur n'est pas égale à 0, le code suivant s'exécute.

    => Corresponds a la vérficaiton d'un debugguer: if ( NtCurrentPeb()->BeingDebugged )

    */
    {
        /*
        Une boucle do-while parcourt des blocs de 4 octets de mémoire en utilisant un pointeur i initialisé à nullptr.
        À l'intérieur de la boucle, des opérations XOR bit à bit sont effectuées sur des octets de la mémoire pointée
        par i et des chaînes de caractères codées en dur. Le but de ces manipulations n'est pas clair sans plus d'informations.
        Ensuite, la variable globale data_4030e8 est mise à 0 et une fonction inconnue 0x78b027ba est appelée en lui passant 
        l'adresse 0x4030c8. Enfin, la fonction renvoie 1.
        */
        void* i = nullptr;
        do
        {
            char ecx_1 = *(i + "dff0c4b58c50d03d713d4545567ed1e");
            *(i + 0x4030c8) = (*(i + 0x4030c8) ^ *(i + "ddff0c4b58c50d03d713d4545567ed1e"));
            *(i + 0x4030c9) = (*(i + 0x4030c9) ^ ecx_1);
            char ecx_2 = *(i + "f0c4b58c50d03d713d4545567ed1e");
            *(i + 0x4030ca) = (*(i + 0x4030ca) ^ *(i + "ff0c4b58c50d03d713d4545567ed1e"));
            *(i + 0x4030cb) = (*(i + 0x4030cb) ^ ecx_2);
            i = (i + 4);
        } while (i < 0x20);
        data_4030e8 = 0;
        0x78b027ba(0x4030c8);
        return 1;
    }
    /*Impression d'une chaîne de caractères et appels à des fonctions inconnues 
    si arg1 >= 2 et la condition précédente est fausse
    
    Imprime une chaîne de caractères obtenue en appelant la fonction sub_401000 
    avec la valeur extraite de la mémoire pointée par arg2 + 4 (Arg2+4 = le char passé en argument)
    
    Plusieurs appels à des fonctions inconnues (&data_403110, &data_403170) 
    sont effectués en leur passant différentes adresses et chaînes de caractères codées en dur.
    => Fonction de bait ? Voir les adresse 403110 et 403170 dans IDA
    */
    printf(0x4020f8, sub_401000(*(arg2 + 4))); //Fais une comparaison entre un arg1 et la chaine "bdea63d1cb70184f84d9d0585c8c7e96" et printf le resultat
    
    &data_403110(0x403170, 0x5f, "c74a29496f3e95ce11fdfd91952c90ee");
    &data_403170(0x4030a8, 0x20, "07d3cf1f90a0fa7ec951b53069b52ddf");
    &data_403170(0x403020, 0x88, "a494aa2dad29c2fe787909ecf13a93e3");
    &data_403170(0x4030ec, 0x20, "afbd88183ed59feb9ff1474c055fe4b5");
    &data_403170(0x4030c8, 0x20, "ddff0c4b58c50d03d713d4545567ed1e");

    /* En mémoire, 403170 donne ce code assembleur:
    .data:00403170 loc_403170:                             ; CODE XREF: _main+D3p
.data:00403170                                         ; _main+E9p ...
.data:00403170                 db      36h
.data:00403170                 mov     esp, 31DEE2D8h
.data:00403176                 rep jl short near ptr loc_40313D+6
.data:00403179                 xor     sp, [ebp+39h]
.data:0040317D                 db      26h
.data:0040317D                 repne popf
.data:00403180                 xor     [ecx], esi
.data:00403182                 db      64h
.data:00403182                 lea     bp, [ebp-4Eh]
.data:00403187                 jz      short loc_40314A
.data:00403189                 mov     dh, 0F2h
.data:0040318B                 bound   esi, [eax+7AE89D75h]
.data:00403191                 int     3               ; Trap to Debugger
.data:00403192                 pop     edx
.data:00403193                 jg      short near ptr loc_4031C5+5
.data:00403195                 inc     edi
.data:00403196                 or      eax, 7ACF1BB5h
.data:0040319B                 dec     esp
.data:0040319C                 xor     ah, [eax+646631CDh]
.data:004031A3                 out     dx, ax
.data:004031A5                 insb
.data:004031A6                 and     [edx], edi
.data:004031A8                 pusha
.data:004031A9                 into
.data:004031AA                 insb
.data:004031AB                 xchg    esi, [edx]
.data:004031AD                 out     dx, al
.data:004031AE                 db      2Eh
.data:004031AE                 aas
.data:004031B0                 aaa
.data:004031B1                 sub     al, 0CAh
.data:004031B3                 mov     ch, ss:[eax]
.data:004031B6                 add     eax, 3120B8B6h
.data:004031BB                 db      36h, 26h
.data:004031BB                 popf
.data:004031BE                 mov     ecx, 9A29ED21h
.data:004031C3                 out     0F8h, eax       ; AT 80287 data.
.data:004031C3                                         ; 286 sends opcodes & operands and receives results.
    */

    // Je sais pas ce que ca fou la
    data_4030e8 = 0;



    if (&data_403020(*(arg2 + 4)) == 0)
    /*
     Cette condition vérifie si une autre valeur extraite de la mémoire pointée par arg2 + 4
      est égale à l'adresse de la variable globale data_403020 (voir jsute en dessous)
      Si la condition est vraie, une fonction inconnue 0x78b0032b est appelée 
      en lui passant l'adresse 0x4030ec, puis la fonction renvoie 1.

      => loc_403020:
        403020 xor al, 0BFh         -> XOR le registre al avec la valeur hexadécimale 0BF
        403022 aad 0B7h             -> Additionne avec décalage le registre al avec la valeur hexadécimale 0B7
        403024 lea eax, [ecx+61h]   -> Charge l'adresse effective de l'octet à l'offset 61h du registre ecx dans le registre eax
        403027 xor dh, [esi]        -> XOR le registre dh avec la valeur du byte pointé par le registre esi
    
    0x78b0032b => Pas trouvé d'info dessus

    */
    {
        0x78b0032b(0x4030ec);
        return 1;
    }

    /*
    Imprime une chaîne de caractères liée à l'adresse 0x4030a8
    0x4030a8 => Pas trouvé d'info dans IDA... Y a une liste d'instruction assembleur
    */
    printf(&data_4020fc, 0x4030a8);

    /*
    Boucle infinie avec une instruction nop en assembleur
    */
    while (true)
    {
        /* nop */
    }
}

int32_t _pre_cpp_init()
{
    _atexit(0x4015a2);
    int32_t var_8 = data_4032a8;
    data_40329c = data_4032ac;
    int32_t eax_1 = __getmainargs(0x403288, 0x403290, 0x40328c, var_8, 0x40329c);
    data_403298 = eax_1;
    if (eax_1 < 0)
    {
        eax_1 = _amsg_exit(8);
    }
    return eax_1;
}

//Intialise des mecanismes de securite + gestion exceptions
int32_t sub_401221()
{
    int32_t __saved_ebp_2 = 0x10;
    int32_t var_8 = 0x4021e8;
    int32_t (* var_10)(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) = __except_handler4;
    int32_t* fsbase;
    int32_t var_14 = *fsbase;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_8_4 = (0x4021e8 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_34 = (__security_cookie_1 ^ &__saved_ebp);
    int32_t* var_1c = &var_34;
    void* const var_38_2 = &data_40122d;
    int32_t var_8_5 = 0xfffffffe;
    int32_t var_c = var_8_4;
    *fsbase = &var_14;
    if (data_4035f0 == 0)
    {
        HeapSetInformation(nullptr, HeapEnableTerminationOnCorruption, nullptr, 0);
    }
    int32_t var_8_1 = 0;
    int32_t esi = *(fsbase[6] + 4);
    int32_t var_20 = 0;
    while (true)
    {
        int32_t eax_1 = InterlockedCompareExchange(0x4035e4, esi, 0);
        if (eax_1 == 0)
        {
            break;
        }
        if (eax_1 == esi)
        {
            var_20 = 1;
            break;
        }
        Sleep(0x3e8);
    }
    int32_t eax_5;
    if (data_4035e0 == 1)
    {
        _amsg_exit(0x1f);
    }
    else if (data_4035e0 != 0)
    {
        data_4032a4 = 1;
    }
    else
    {
        data_4035e0 = 1;
        if (_initterm_e(0x4020b4, 0x4020c0) != 0)
        {
            int32_t var_8_2 = 0xfffffffe;
            eax_5 = 0xff;
        label_401778:
            *fsbase = var_14;
            void* const __saved_ebp_1 = &data_4013a9;
            return eax_5;
        }
    }
    if (data_4035e0 == 1)
    {
        _initterm(0x4020a8, 0x4020b0);
        data_4035e0 = 2;
    }
    if (var_20 == 0)
    {
        InterlockedExchange(0x4035e4, 0);
    }
    if ((data_4035f4 != 0 && sub_401660(0x4035f4) != 0))
    {
        data_4035f4(0, 2, 0);
    }
    *__initenv = data_40328c;
    int32_t var_38 = data_40328c;
    int32_t status = sub_401080(data_403288, data_403290); //Appel de la fonction principale
    data_4032a0 = status;
    if (data_403294 == 0) //Si le nombre d'arg est inférieure a 2
    {
        exit(status); 
        /* no return */
    }
    if (data_4032a4 == 0)
    {
        _cexit();
    }
    int32_t var_8_3 = 0xfffffffe;
    eax_5 = data_4032a0;
    goto label_401778;
}

int32_t sub_4013aa()
{
    data_403294 = 0;
    __set_app_type(1);
    int32_t eax = EncodePointer(0xffffffff);
    int32_t ecx_1 = data_4032b4;
    data_4035e8 = eax;
    data_4035ec = eax;
    *_fmode = ecx_1;
    *_commode = data_4032b0;
    sub_40157c();
    if (data_403014 == 0)
    {
        __setusermatherr(sub_4017d6);
    }
    sub_4017ae();
    if (data_403010 == 0xffffffff)
    {
        _configthreadlocale(0xffffffff);
    }
    return 0;
}

int32_t _start()
{
    sub_4017d9();
    /* tailcall */
    return sub_401221();
}

int32_t __stdcall sub_40146e(int32_t* arg1)
{
    int32_t* eax_1 = *arg1;
    if ((*eax_1 == 0xe06d7363 && eax_1[4] == 3))
    {
        int32_t eax_2 = eax_1[5];
        if ((((eax_2 == 0x19930520 || eax_2 == 0x19930521) || eax_2 == 0x19930522) || eax_2 == 0x1994000))
        {
            terminate();
        }
    }
    return 0;
}

int32_t sub_4014b0()
{
    SetUnhandledExceptionFilter(sub_40146e);
    return 0;
}

int32_t _amsg_exit()
{
    /* tailcall */
    return _amsg_exit();
}

int32_t sub_4014c4(int32_t arg1)
{
    int32_t __saved_ebp_2 = 0x14;
    int32_t var_8 = 0x402208;
    int32_t (* var_10)(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) = __except_handler4;
    int32_t* fsbase;
    int32_t var_14 = *fsbase;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_8_3 = (0x402208 ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_38 = (__security_cookie_1 ^ &__saved_ebp);
    int32_t* var_1c = &var_38;
    void* const var_3c_7 = &data_4014d0;
    int32_t var_8_4 = 0xfffffffe;
    int32_t var_c = var_8_3;
    *fsbase = &var_14;
    int32_t eax = DecodePointer(data_4035ec);
    int32_t var_20 = eax;
    int32_t eax_1;
    if (eax != 0xffffffff)
    {
        _lock(8);
        int32_t var_8_1 = 0;
        var_20 = DecodePointer(data_4035ec);
        int32_t var_24 = DecodePointer(data_4035e8);
        int32_t eax_5 = __dllonexit(EncodePointer(arg1), &var_20, &var_24);
        data_4035ec = EncodePointer(var_20);
        data_4035e8 = EncodePointer(var_24);
        int32_t var_8_2 = 0xfffffffe;
        sub_40155c();
        eax_1 = eax_5;
    }
    else
    {
        eax_1 = _onexit(arg1);
    }
    *fsbase = var_14;
    void* const __saved_ebp_1 = &data_40155b;
    return eax_1;
}

int32_t sub_40155c()
{
    return _unlock(8);
}

int32_t _atexit(int32_t arg1)
{
    int32_t eax = sub_4014c4(arg1);
    int32_t eax_1 = -(eax);
    return (-((eax_1 - eax_1)) - 1);
}

void sub_40157c()
{
    int32_t edi;
    int32_t var_8 = edi;
}

void sub_4015a4()
{
    return;
}

int32_t _XcptFilter()
{
    /* tailcall */
    return _XcptFilter();
}

int32_t sub_4015d0(int16_t* arg1)
{
    if (*arg1 == 0x5a4d)
    {
        void* eax_3 = (*(arg1 + 0x3c) + arg1);
        if (*eax_3 == 0x4550)
        {
            int32_t edx;
            edx = *(eax_3 + 0x18) == 0x10b;
            return edx;
        }
    }
    return 0;
}

void* sub_401610(void* arg1, int32_t arg2)
{
    void* ecx_1 = (*(arg1 + 0x3c) + arg1);
    uint32_t esi = *(ecx_1 + 6);
    int32_t edx = 0;
    int32_t edi;
    int32_t var_10 = edi;
    void* eax_2 = ((*(ecx_1 + 0x14) + ecx_1) + 0x18);
    if (esi != 0)
    {
        do
        {
            int32_t ecx_2 = *(eax_2 + 0xc);
            if ((arg2 >= ecx_2 && arg2 < (*(eax_2 + 8) + ecx_2)))
            {
                return eax_2;
            }
            edx = (edx + 1);
            eax_2 = (eax_2 + 0x28);
        } while (edx < esi);
    }
    return nullptr;
}

int32_t sub_401660(int32_t arg1)
{
    int32_t var_8 = 0xfffffffe;
    int32_t var_c = 0x402228;
    int32_t (* var_10)(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) = __except_handler4;
    int32_t* fsbase;
    int32_t var_14 = *fsbase;
    int32_t edi;
    int32_t var_28 = edi;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t var_c_1 = (var_c ^ __security_cookie_1);
    int32_t __saved_ebp;
    int32_t var_2c = (__security_cookie_1 ^ &__saved_ebp);
    *fsbase = &var_14;
    int32_t* var_1c = &var_2c;
    int32_t var_8_1 = 0;
    if (sub_4015d0(&__dos_header) != 0)
    {
        void* eax_5 = sub_401610(&__dos_header, (arg1 - 0x400000));
        if (eax_5 != 0)
        {
            int32_t eax_9 = (!((*(eax_5 + 0x24) >> 0x1f)) & 1);
            int32_t var_8_2 = 0xfffffffe;
            *fsbase = var_14;
            return eax_9;
        }
    }
    int32_t var_8_3 = 0xfffffffe;
    *fsbase = var_14;
    return 0;
}

int32_t sub_4016eb(void* arg1 @ ebp)
{
    int32_t edx;
    edx = ***(arg1 - 0x14) == 0xc0000005;
    return edx;
}

int32_t _initterm()
{
    /* tailcall */
    return _initterm();
}

int32_t _initterm_e()
{
    /* tailcall */
    return _initterm_e();
}

void* __SEH_prolog4(int32_t arg1 @ esi, int32_t arg2 @ edi, void* arg3)
{
    int32_t (* var_4)(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4) = __except_handler4;
    int32_t* fsbase;
    int32_t var_8 = *fsbase;
    int32_t eax = arg_8;
    int32_t ebp;
    arg_8 = ebp;
    void* esp = (&var_8 - eax);
    int32_t ebx;
    *(esp - 4) = ebx;
    *(esp - 8) = arg1;
    *(esp - 0xc) = arg2;
    uint32_t __security_cookie_1 = __security_cookie;
    *(esp - 0x10) = (__security_cookie_1 ^ &arg_8);
    void* var_10 = (esp - 0x10);
    *(esp - 0x14) = __return_addr;
    void* __return_addr_1 = (arg3 ^ __security_cookie_1);
    arg3 = 0xfffffffe;
    __return_addr = __return_addr_1;
    *fsbase = &var_8;
    return __return_addr_1;
}

int32_t __SEH_epilog4(int32_t* arg1 @ ebp, int32_t arg2, int32_t arg3, int32_t arg4)
{
    int32_t* fsbase;
    *fsbase = arg1[-4];
    *arg1;
    *arg1 = __return_addr;
}

int32_t __except_handler4(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
    return _except_handler4_common(0x403018, sub_40188c, arg1, arg2, arg3, arg4);
}

int32_t sub_4017ae()
{
    int32_t eax = _controlfp_s(0, 0x10000, 0x30000);
    if (eax == 0)
    {
        return eax;
    }
    _invoke_watson(nullptr, nullptr, nullptr, 0, 0);
    /* no return */
}

int32_t sub_4017d6() __pure
{
    return 0;
}

//Verifie le curretnt process ??
uint32_t sub_4017d9()
{
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t lpSystemTimeAsFileTime = 0;
    int32_t var_8 = 0;
    int32_t edi;
    int32_t var_1c = edi;
    uint32_t eax;
    if ((__security_cookie_1 == 0xbb40e64e || (__security_cookie_1 != 0xbb40e64e && (0xffff0000 & __security_cookie_1) == 0)))
    {
        GetSystemTimeAsFileTime(&lpSystemTimeAsFileTime);
        int32_t esi_5 = ((((var_8 ^ lpSystemTimeAsFileTime) ^ GetCurrentProcessId()) ^ GetCurrentThreadId()) ^ GetTickCount());
        int32_t lpPerformanceCount;
        QueryPerformanceCounter(&lpPerformanceCount);
        int32_t var_10;
        eax = (var_10 ^ lpPerformanceCount);
        uint32_t esi_6 = (esi_5 ^ eax);
        if (esi_6 == 0xbb40e64e)
        {
            esi_6 = 0xbb40e64f;
        }
        else if ((0xffff0000 & esi_6) == 0)
        {
            eax = ((esi_6 | 0x4711) << 0x10);
            esi_6 = (esi_6 | eax);
        }
        __security_cookie = esi_6;
        data_40301c = !(esi_6);
    }
    if ((__security_cookie_1 != 0xbb40e64e && (0xffff0000 & __security_cookie_1) != 0))
    {
        eax = !(__security_cookie_1);
        data_40301c = eax;
    }
    return eax;
}

void terminate()
{
    /* tailcall */
    return terminate();
}

int32_t _unlock()
{
    /* tailcall */
    return _unlock();
}

int32_t __dllonexit()
{
    /* tailcall */
    return __dllonexit();
}

int32_t _lock()
{
    /* tailcall */
    return _lock();
}

void __fastcall sub_40188c(int32_t arg1)
{
    int32_t eax;
    int32_t edx;
    int32_t ebp;
    int32_t esi;
    int32_t edi;
    if (arg1 != __security_cookie)
    {
        /* tailcall */
        return sub_4018ae(eax, edx, arg1, ebp, esi, edi);
    }
}

int32_t _except_handler4_common()
{
    /* tailcall */
    return _except_handler4_common();
}

void _invoke_watson(wchar16 const* const expression, wchar16 const* const function_name, wchar16 const* const file_name, uint32_t const line_number, uint32_t const reserved) __noreturn
{
    /* tailcall */
    return _invoke_watson(expression, function_name, file_name, line_number, reserved);
}

int32_t _controlfp_s()
{
    /* tailcall */
    return _controlfp_s();
}

BOOL __convention("regparm") sub_4018ae(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4 @ ebp, int32_t arg5 @ esi, int32_t arg6 @ edi)
{
    bool p = /* bool p = unimplemented  {sub esp, 0x328} */;
    bool a = /* bool a = unimplemented  {sub esp, 0x328} */;
    data_4033c0 = arg1;
    data_4033bc = arg3;
    data_4033b8 = arg2;
    int32_t ebx;
    data_4033b4 = ebx;
    data_4033b0 = arg5;
    data_4033ac = arg6;
    int16_t ss;
    data_4033d8 = ss;
    int16_t cs;
    data_4033cc = cs;
    int16_t ds;
    data_4033a8 = ds;
    int16_t es;
    data_4033a4 = es;
    int16_t fs;
    data_4033a0 = fs;
    int16_t gs;
    data_40339c = gs;
    int32_t var_32c;
    int32_t var_4;
    bool d;
    int32_t var_330 = (((((&var_4 - 0x328)) ? 1 : 0) << 0xb) | ((((d) ? 1 : 0) << 0xa) | ((((&var_32c < 0) ? 1 : 0) << 7) | ((((&var_4 == 0x328) ? 1 : 0) << 6) | ((((a) ? 1 : 0) << 4) | ((((p) ? 1 : 0) << 2) | (((&var_4 < 0x328) ? 1 : 0) << 0)))))));
    data_4033d0 = var_330;
    data_4033c4 = arg4;
    data_4033c8 = __return_addr;
    data_4033d4 = &arg_4;
    data_403310 = 0x10001;
    data_4032c4 = data_4033c8;
    data_4032b8 = 0xc0000409;
    data_4032bc = 1;
    uint32_t __security_cookie_1 = __security_cookie;
    int32_t eax_3 = data_40301c;
    data_403308 = IsDebuggerPresent();
    _crt_debugger_hook(1, __security_cookie_1, eax_3);
    SetUnhandledExceptionFilter(nullptr);
    UnhandledExceptionFilter(&data_4020ec);
    if (data_403308 == 0)
    {
        _crt_debugger_hook(1);
    }
    return TerminateProcess(GetCurrentProcess(), 0xc0000409);
}

int32_t _crt_debugger_hook()
{
    /* tailcall */
    return _crt_debugger_hook();
}

